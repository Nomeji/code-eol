{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.map","sourceRoot":"..","sourcesContent":["\"use strict\"\nObject.defineProperty(exports, \"__esModule\", { value: true })\nconst vscode = require(\"vscode\")\n\n// \n// init vars\n//\nlet isDisabled = null\nlet whitespaceWasActive = null\n// create a mainDecoration with nothing in it because we're not actually decorating any existing text \n// instead we're finding end-of-lines, then adding something after them, and then decorating that \"something-after\" thing\nconst mainDecoration = vscode.window.createTextEditorDecorationType({})\nlet activeEditor\nlet globalState\n// the pattern to find the differnt line endings\nconst endOfLinePattern = /\\r\\n|\\n|\\r/g\nlet match\nlet theRenderOption\n// each of the 4 render possibilities\nlet renderNewline\nlet renderReturn\nlet renderCrlf\nlet renderBlank\n\n// \n// Update colors\n//\nfunction updateSettings() {\n    //\n    // import stuff from settings.json\n    //\n    let {\n        style,\n        newlineCharacter,\n        newlineCharacterStyle,\n        returnCharacter,\n        returnCharacterStyle,\n        crlfCharacter,\n        crlfCharacterStyle,\n        validLineEnding,\n        toggleWithWhiteSpace,\n    } = vscode.workspace.getConfiguration('code-eol')\n    let whitespaceIsBeingRendered = vscode.workspace.getConfiguration('editor', null).get('renderWhitespace', false) != 'none'\n    // make style editable (by default it is read only when its imported from settings)\n    style = {\n        // set default color to be the color of whitespace\n        color: new vscode.ThemeColor('editorWhitespace.foreground'),\n        ...style\n    }\n\n    // \n    // Check for non-default line endings\n    // \n    if (validLineEnding != null) {\n        const themeErrorColor = new vscode.ThemeColor('errorForeground')\n        if (validLineEnding == 'LF') {\n            crlfCharacterStyle   = { color: themeErrorColor, ...crlfCharacterStyle  }\n            returnCharacterStyle = { color: themeErrorColor, ...returnCharacterStyle}\n        } else if (validLineEnding == 'CRLF') {\n            newlineCharacterStyle = { color: themeErrorColor, ...newlineCharacterStyle}\n            returnCharacterStyle  = { color: themeErrorColor, ...returnCharacterStyle }\n        }\n    }\n\n    // convert opacity into a string (not sure why it fails when its a number)\n    if (typeof style.opacity == \"number\") { style.opacity = `${style.opacity}` }\n    newlineCharacterStyle = {...newlineCharacterStyle}; if (typeof newlineCharacterStyle.opacity == \"number\") { newlineCharacterStyle.opacity = `${newlineCharacterStyle .opacity}` }\n    returnCharacterStyle  = {...returnCharacterStyle }; if (typeof returnCharacterStyle .opacity == \"number\") { returnCharacterStyle .opacity = `${returnCharacterStyle  .opacity}` }\n    crlfCharacterStyle    = {...crlfCharacterStyle   }; if (typeof crlfCharacterStyle   .opacity == \"number\") { crlfCharacterStyle   .opacity = `${crlfCharacterStyle    .opacity}` }\n    \n    // set the style/look/decoration of each line ending\n    renderNewline = { after: { contentText: newlineCharacter, ...style, ...newlineCharacterStyle } }\n    renderReturn  = { after: { contentText: returnCharacter , ...style, ...returnCharacterStyle  } }\n    renderCrlf    = { after: { contentText: crlfCharacter   , ...style, ...crlfCharacterStyle    } }\n    renderBlank   = { after: { contentText: ''              , ...style,                 } }\n    \n    // \n    // Check for change in showing whitespace (check for if it should be toggled)\n    // \n    if (whitespaceWasActive != whitespaceIsBeingRendered) {\n        // save change to perisitant storage\n        whitespaceWasActive = !whitespaceWasActive\n        if (globalState) {\n            globalState.update(\"whitespaceWasActive\", whitespaceWasActive)\n        }\n        // if user has setting enabled\n        if (toggleWithWhiteSpace) {\n            if (whitespaceIsBeingRendered) {\n                isDisabled = false\n            } else {\n                isDisabled = true\n            }\n            if (globalState) {\n                globalState.update(\"codeEolIsDisabled\", isDisabled)\n            }\n        }\n    }\n} \n\n\n// \n// this method is called when vs code is initally opened\n// \nexports.activate = function activate(context) {\n    // set the active editor\n    activeEditor = vscode.window.activeTextEditor\n    // set the globalState\n    globalState = context.globalState\n    // get the isDisabled setting\n    isDisabled          = context.globalState.get(\"codeEolIsDisabled\")\n    whitespaceWasActive = context.globalState.get(\"whitespaceWasActive\")\n    let isRunningV1     = context.globalState.get(\"isRunningV1\")\n\n\n    updateSettings()\n    \n    // update message for v1\n    if (isRunningV1 != true) {\n        vscode.window.showInformationMessage('Hey! The big update to code-eol might break the look of your line-endings. Check the extension homepage for more details')\n        if (globalState) {\n            globalState.update(\"isRunningV1\", true)\n        }\n    }\n\n    // \n    // bind updateDecorations()\n    // \n    // updateDecorations on activation\n    updateDecorations()\n    // updateDecorations whenever the doc changes \n    vscode.workspace.onDidChangeTextDocument(()=>updateDecorations(), null, context.subscriptions)\n    // updateDecorations when the editor changes (aka new tab)\n    vscode.window.onDidChangeActiveTextEditor(updateDecorations, null, context.subscriptions)\n\n    // \n    // when the user changes settings, update the color varaibles\n    // \n    vscode.workspace.onDidChangeConfiguration(() => {\n        updateSettings()\n        updateDecorations()\n    }, null, context.subscriptions)\n}\n\n// \n// the render function for actually showing newlines\n// \nfunction updateDecorations(editor) {\n    // if there is a new editor (aka new tab), then update activeEditor\n    if (editor) { activeEditor = editor }\n    // if somehow there is no active editor, then just return\n    if (!activeEditor) { return }\n    \n    // if this called by onDidChangeTextDocument(), \n    // then the text string will only be the text that changed\n    // (it wont be the text of the entire file)\n    const document = activeEditor.document\n    const text = document.getText()\n    const newLines = []\n    \n    // if disabled, update the page to show nothing (otherwise the old line endings will stick around)\n    if (isDisabled) {\n        activeEditor.setDecorations(mainDecoration, newLines)\n    // if enabled then continue to render everything\n    } else {\n        // loop through every line ending match\n        while (match = endOfLinePattern.exec(text)) {\n            // find which ending this particular match is\n            switch (match[0]) {\n                case '\\n'  : theRenderOption = renderNewline; break\n                case '\\r\\n': theRenderOption = renderCrlf   ; break\n                case '\\r'  : theRenderOption = renderReturn ; break\n                default    : theRenderOption = renderBlank  ; break\n            }\n            let startingPosition = document.positionAt(match.index)\n            let lineDecoration = {\n                // just use startPos twice since we dont want to decorate any existing text\n                range: new vscode.Range(startingPosition, startingPosition),\n                renderOptions: theRenderOption\n            }\n            newLines.push(lineDecoration)\n        }\n        if (activeEditor.setDecorations) {\n            activeEditor.setDecorations(mainDecoration, newLines)\n        }\n    }\n}\n\n// \n// register a command for toggling the line endings\n// \nvscode.commands.registerCommand('extension.toggleLineEndings', () => {\n    // disable the flag\n    isDisabled = !isDisabled\n    // then tell the current file to update (either add or remove the line endings)\n    updateDecorations()\n    // after render, change toggle the storage option too\n    // (this makes the setting perisitant even after restarting vs code)\n    if (globalState) {\n        globalState.update(\"codeEolIsDisabled\", isDisabled)\n    }\n})\n\n"]}